<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WindBorne Flight Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    html,body,#map{height:100%;margin:0}
    .hud{position:fixed;left:8px;top:8px;background:#fff;padding:8px 10px;border-radius:8px;
         font:12px/1.3 system-ui,Segoe UI,Roboto,Arial;border:1px solid #ddd}
    .err{color:#b00}
  </style>
</head>
<body>
<div id="map"></div>
<div class="hud" id="hud">Loading…</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const HUD = document.getElementById('hud');
const BASE = "https://windborne-cors-proxy.keerthanareddypanyala.workers.dev/treasure";
const HOURS = Array.from({length:24}, (_,i)=>String(i).padStart(2,"0"));

/* ---------- helpers ---------- */
function num(n){ const v = Number(n); return Number.isFinite(v) ? v : null; }
function fixDeg(v){                 // handle micro-degrees, strings, etc.
  let n = num(v); if(n==null) return null;
  if(Math.abs(n)>180 && Math.abs(n)<=1e7) n = n/1e6;
  return Math.abs(n)<=180 ? n : null;
}
function firstKey(obj, keys){
  for(const k of keys){ if(obj?.[k]!=null) return obj[k]; }
  return null;
}

/* Try hard to turn any record into {id,lat,lon,t} */
function toPoint(rec){
  if(!rec || typeof rec!=="object") return null;

  // GeoJSON support
  if(rec.type==="Feature" && rec.geometry?.type==="Point"){
    const [lon,lat] = rec.geometry.coordinates||[];
    const t = firstKey(rec.properties||rec, ['ts','time','timestamp','datetime','t','updatedAt']);
    const id = firstKey(rec.properties||rec, ['id','balloon_id','name']);
    return (lat!=null && lon!=null) ? norm({id, lat, lon, t}) : null;
  }

  // Common flat shapes
  const lat = fixDeg(firstKey(rec, ['lat','latitude','latDeg','Lat','LAT','y']));
  const lon = fixDeg(firstKey(rec, ['lon','lng','longitude','lonDeg','Lon','LON','x']));
  const t   = firstKey(rec, ['ts','time','timestamp','datetime','t','updatedAt']);
  const id  = firstKey(rec, ['id','balloon_id','name']) ?? 'balloon';

  if(lat!=null && lon!=null) return norm({id, lat, lon, t});
  return null;

  function norm(p){
    return { id: String(p.id), lat: +p.lat, lon: +p.lon,
             t: p.t ? new Date(p.t) : null };
  }
}

/* Flatten any crazy nesting into a list of candidate records */
function collectCandidates(data){
  const out = [];
  (function walk(x, depth=0){
    if(depth>3) return;                           // keep it light
    if(Array.isArray(x)){ x.forEach(v=>walk(v, depth+1)); return; }
    if(x && typeof x==="object"){
      // If object looks like a point already, push it
      if(Object.keys(x).some(k=>/lat|lon|lng|latitude|longitude/i.test(k))){
        out.push(x);
      }else{
        // walk common containers
        for(const k of ['points','data','items','features']) if(x[k]) walk(x[k], depth+1);
        Object.values(x).forEach(v=>walk(v, depth+1));
      }
    }
  })(data);
  return out;
}

/* ---------- data fetch ---------- */
async function fetchHour(hh){
  try{
    const r = await fetch(`${BASE}/${hh}.json`, {cache:'no-store'});
    if(!r.ok) throw new Error(`HTTP ${r.status}`);
    const j = await r.json();
    const candidates = collectCandidates(j);
    return candidates.map(toPoint).filter(Boolean);
  }catch(e){
    console.warn('hour',hh,'failed:',e);
    return [];
  }
}

async function loadTracks(){
  const settled = await Promise.allSettled(HOURS.map(fetchHour));
  const pts = settled.flatMap(s=>s.status==='fulfilled'?s.value:[]);
  // group by id
  const byId = new Map();
  for(const p of pts){
    const arr = byId.get(p.id) || [];
    arr.push(p); byId.set(p.id, arr);
  }
  // sort each track by time and dedupe consecutive identical coords
  for(const [id,arr] of byId){
    arr.sort((a,b)=>(a.t?.getTime()||0)-(b.t?.getTime()||0));
    byId.set(id, arr.filter((p,i)=>i===0 || p.lat!==arr[i-1].lat || p.lon!==arr[i-1].lon));
  }
  return byId;
}

/* ---------- map ---------- */
const map = L.map('map').setView([20,0], 2);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:7,attribution:'© OSM'}).addTo(map);

let layerGroup = L.layerGroup().addTo(map);

async function render(){
  HUD.textContent = 'Loading last 24h…';
  const tracks = await loadTracks();
  layerGroup.clearLayers();
  let balloonCount = 0, pointCount = 0;

  for(const [id,arr] of tracks){
    if(!arr.length) continue;
    balloonCount++;
    pointCount += arr.length;
    const latlngs = arr.map(p=>[p.lat,p.lon]);
    L.polyline(latlngs, {weight:2, opacity:0.8}).addTo(layerGroup);
    const last = arr[arr.length-1];
    L.marker([last.lat,last.lon]).addTo(layerGroup)
      .bindPopup(`<b>${id}</b><br>${last.t?last.t.toUTCString():'no time'}`);
  }
  HUD.innerHTML = pointCount
    ? `Balloons: <b>${balloonCount}</b> • Points: <b>${pointCount}</b> • Updated: ${new Date().toUTCString()}`
    : `<span class="err">No points parsed. Open DevTools → Console for fetch/parse logs.</span>`;
}

render();
setInterval(render, 5*60*1000); // refresh every 5 minutes
</script>
</body>
</html>


